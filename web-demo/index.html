<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Midiverb I/II Emulator Demo</title>
</head>
<body>
  <h1>Midiverb I/II Emulator Demo</h1>
  <img src="panel2.png"><br><br><br>
  <button id="startButton">Start Audio</button>
  <button id="pauseButton">Mute effect input</button>
  <button id="stopButton">Stop Audio</button>
  <br><br>
  <label for="engineSelect">Engine: </label>
  <select id="engineSelect">
    <option value="emulated" selected>Emulated (ROM)</option>
    <option value="decompiled">Decompiled (native JS)</option>
    <option value="decompiled_vst">Decompiled (native JS) with VST resampling</option>
  </select>
  <label for="deviceSelect"> Device: </label>
  <select id="deviceSelect">
    <option value="midiverb">MIDIVerb</option>
    <option value="midifex">MIDIFex</option>
    <option value="midiverb2" selected>MIDIVerb 2</option>
  </select>
  <label for="effectProgram"> Effect: </label>
  <select id="effectProgram"></select>
  <br>
  <br>
  <input type="range" id="dryWetMix" name="dryWetMix" min="0" max="100" value="50">
  <label for="dryWetMix">Mixing desk Dry/Wet Mix</label>
  <br>
  <br>
  <input type="range" id="feedbackAmount" name="feedbackAmount" min="0" max="250" value="0">
  <label for="feedbackAmount">Mixing desk Feedback (DANGEROUS, goes to 250%)</label>
  <br>
  <br>
  <label for="soundSelect">Sound Source: </label>
  <select id="soundSelect">
    <option value="example.wav">Example WAV</option>
    <option value="sine_blip">Sine Wave Blip (440Hz, 100ms)</option>
    <option value="sine_wave">Sine Wave (440Hz, 25% vol, 2s)</option>
    <option value="noise_burst">Noise Burst (250ms)</option>
    <option value="impulse">Impulse (click)</option>
    <option value="chord_sweep">Maj7 Chord Sweep</option>
    <option value="custom">Custom WAV...</option>
  </select>
  <input type="file" id="fileInput" accept=".wav" style="display: none;">
<br>
<br>
  <div id="disassemblyContainer"></div>
  <br><br><br>
<pre>
sources at <a href="https://github.com/thement/midiverb_emulator">https://github.com/thement/midiverb_emulator</a>
code by thement at ibawizard do net
</pre>
<button id="fillDramButton">Fill DRAM with Random Numbers</button> - LOUD! Check how it sounds right after Power-On
  <script src="sound-generators.js"></script>
  <script src="decompiled-midiverb.js"></script>
  <script src="decompiled-midifex.js"></script>
  <script src="decompiled-midiverb2.js"></script>
  <script>
  // ROM type definitions
  const ROM_TYPES = {
    midiverb: {
      name: "MIDIVerb",
      romFile: "midiverb.rom",
      romLength: 16384,
      firstProgram: 1,
      lastProgram: 64,
      bytecodeOffset: 0,
      memoryShift: 2,
      hasLfo: false,
      interpolationPatchTableOffset: 0,
      effectNames: [
        ".2 Sec SMALL BRIGHT", ".2 Sec SMALL WARM", ".2 Sec MEDIUM BRIGHT",
        ".3 Sec SMALL BRIGHT", ".3 Sec SMALL WARM", ".4 Sec MEDIUM BRIGHT",
        ".4 Sec MEDIUM WARM", ".6 Sec SMALL BRIGHT", ".6 Sec MEDIUM WARM",
        ".6 Sec MEDIUM DARK", ".8 Sec SMALL BRIGHT", ".8 Sec LARGE WARM",
        "1.0 Sec SMALL WARM", "1.0 Sec MEDIUM WARM", "1.0 Sec LARGE BRIGHT",
        "1.2 Sec MEDIUM WARM", "1.2 Sec SMALL WARM", "1.2 Sec SMALL BRIGHT",
        "1.4 Sec LARGE WARM", "1.4 Sec LARGE DARK", "1.4 Sec MEDIUM WARM",
        "1.6 Sec SMALL DARK", "1.6 Sec LARGE BRIGHT", "1.6 Sec MEDIUM BRIGHT",
        "1.8 Sec LARGE DARK", "1.8 Sec LARGE BRIGHT", "1.8 Sec MEDIUM WARM",
        "2.0 Sec LARGE BRIGHT", "2.0 Sec MEDIUM WARM", "2.0 Sec LARGE WARM",
        "2.5 Sec MEDIUM WARM", "2.5 Sec LARGE BRIGHT", "2.5 Sec MEDIUM DARK",
        "2.8 Sec SMALL BRIGHT", "2.8 Sec MEDIUM BRIGHT", "3.0 Sec LARGE BRIGHT",
        "3.0 Sec LARGE WARM", "3.0 Sec MEDIUM DARK", "3.5 Sec LARGE BRIGHT",
        "3.5 Sec MEDIUM WARM", "4.0 Sec LARGE DARK", "4.0 Sec MEDIUM BRIGHT",
        "5 Sec LARGE WARM", "8 Sec LARGE BRIGHT", "8 Sec LARGE WARM",
        "10 Sec LARGE BRIGHT", "10 Sec LARGE WARM", "16 Sec LARGE DARK",
        "18 Sec EX. LARGE BRIGHT", "20 Sec EX. LARGE DARK", "Gated 100 MS",
        "Gated 150 MS", "Gated 200 MS", "Gated 250 MS", "Gated 300 MS",
        "Gated 350 MS", "Gated 400 MS", "Gated 500 MS", "Gated 600 MS",
        "REVERSE - 300 MS", "REVERSE - 400 MS", "REVERSE - 500 MS",
        "REVERSE - 600 MS", "DEFEAT"
      ]
    },
    midifex: {
      name: "MIDIFex",
      romFile: "midifex.rom",
      romLength: 16384,
      firstProgram: 1,
      lastProgram: 64,
      bytecodeOffset: 0,
      memoryShift: 2,
      hasLfo: false,
      interpolationPatchTableOffset: 0,
      effectNames: [
        "ECHO LONG FLAT AMBI", "ECHO LONG FLAT THICK", "ECHO LONG HPF",
        "ECHO LONG HPF WIDE", "ECHO LONG BPF AMBI", "ECHO LONG LPF WIDE",
        "ECHO MED FLAT AMBI", "ECHO MED FLAT WIDE", "ECHO MED HPF AMBI",
        "ECHO MED BPF AMBI", "ECHO MED LPF AMBI", "ECHO MED LPF WIDE",
        "ECHO MED FLAT THICK", "ECHO SHORT FLAT", "ECHO SHORT LPF AMBI",
        "ECHO SHORT HPF AMBI", "ECHO SHORT BPF AMBI", "ECHO SHORT FLAT",
        "ECHO SHORT FLAT WIDE", "ECHO XSHORT FLAT", "ECHO XSHORT BPF WIDE",
        "2TAP MED FLAT AMBI", "2TAP MED HPF AMBI", "2TAP MED BPF AMBI",
        "2TAP MED FLAT THICK", "2TAP SHORT FLAT WIDE", "2TAP SHORT HPF PAN",
        "2TAP SHORT BPF AMBI", "2TAP SHORT LPF AMBI", "2TAP XSHORT FLAT WIDE",
        "3TAP MED FLAT PAN", "3TAP SHORT FLAT PAN", "3TAP SHORT LPF AMBI",
        "3TAP SHORT BPF AMBI", "3TAP SHORT HPF AMBI", "3TAP XSHORT FLAT AMBI",
        "REGEN MED FLAT", "REGEN MED HPF AMBI", "REGEN MED BPF AMBI",
        "REGEN MED LPF AMBI", "REGEN SHORT FLAT", "REGEN XSHORT FLAT",
        "SLAP1", "SLAP2", "SLAP3", "SLAP4", "SLAP5",
        "REVERB SHORT GATE", "REVERB MEDIUM WARM", "REVERB MEDIUM BLOOM",
        "REVERB MEDIUM PAN", "REVERB LONG HPF", "REVERB REVERSE",
        "REVERB REVERSE REGEN", "MULTITAP PAN", "MULTITAP REVERB",
        "MULTITAP REVERSE PAN", "THICKENER", "THICKENER DENSE",
        "STEREOGEN AMBIENT", "STEREOGEN THICK", "STEREOGEN WIDE",
        "STEREOGEN XWIDE", "DEFEAT"
      ]
    },
    midiverb2: {
      name: "MIDIVerb 2",
      romFile: "midiverb2.rom",
      romLength: 32768,
      firstProgram: 0,
      lastProgram: 99,
      bytecodeOffset: 0x1c00,
      memoryShift: 1,
      hasLfo: true,
      interpolationPatchTableOffset: 0x1b00,
      effectNames: [
        "Defeat", "Small Bright .1 Sec", "Small Bright .2 Sec", "Small Bright .3 Sec",
        "Medium Warm 1.1 Sec", "Medium Bright .6 Sec", "Large Bright 1.2 Sec",
        "Large Dark 1.0 Sec", "Medium Dark .6 Sec", "Medium Dark .5 Sec",
        "Medium Bright .6 Sec", "Medium Bright .8 Sec", "Large Warm 1.0 Sec",
        "Large Warm 1.1 Sec", "Medium Dark 1.0 Sec", "Medium Bright 1.1 Sec",
        "Medium Bright 1.15 Sec", "Large Bright 1.6 Sec", "Large Dark 1.7 Sec",
        "Medium Bright 1.65 Sec", "Medium Bright 1.9 Sec", "Large Warm 2.2 Sec",
        "Large Warm 1.75 Sec", "Large Bright 1.45 Sec", "Large Dark 2.2 Sec",
        "Large Warm 2.3 Sec", "Large Bright 2.4 Sec", "Large Bright 2.5 Sec",
        "Xlarge Warm 5.0 Sec", "Xlarge Warm 15.0 Sec", "Slow Gate 100 Msec",
        "Slow Gate 200 Msec", "Slow Gate 250 Msec", "Slow Gate 400 Msec",
        "Slow Gate 450 Msec", "Fast Gate 150 Msec", "Fast Gate 75 Msec",
        "Fast Gate 200 Msec", "Fast Gate 100 Msec", "Fast Gate 175 Msec",
        "Reverse 400 Msec", "Reverse 450 Msec", "Reverse 250 Msec",
        "Reverse 200 Msec", "Reverse 150 Msec", "Bloom 1 8 Sec",
        "Reverse 500 Msec", "Reverse Regen. 2 Sec", "Reverse Regen. 8 Sec",
        "Bloom 2 7 Sec", "Triggered Flange", "Flange Pan 1", "Flange Pan 2",
        "Triggered Flange 2", "Flange Pan 3", "Flange Pan 4", "Flange Pan 5",
        "Triggered Flange 3", "Flange Pan 6", "Flange Pan 7", "Light Chorus 1",
        "Light Chorus 2", "Medium Chorus 1", "Medium Chorus 2", "Medium Chorus 3",
        "Deep Chorus 1", "Deep Chorus 2", "Deep Chorus 3", "Fast Chorus 1",
        "Fast Chorus 2", "35 Msec", "55 Msec", "75 Msec", "115 Msec", "140 Msec",
        "155 Msec", "160 Msec", "170 Msec", "175 Msec", "180 Msec", "185 Msec",
        "195 Msec", "205 Msec", "210 Msec", "220 Msec", "240 Msec", "250 Msec",
        "275 Msec", "375 Msec", "460 Msec", "2 Tap Ambient", "3 Tap Pan",
        "Multitap", "Multitap Reverse Pan", "Thickener/frozen Flange",
        "Stereo Generation", "Stereo Generation Wide", "Regenerated Delay 2 Sec",
        "Regenerated Delay 3 Sec", "Regenerated Delay 4 Sec"
      ]
    }
  };

  // Decompiled effect functions lookup
  const DECOMPILED_EFFECTS = {
    midiverb: typeof midiverb_effects !== 'undefined' ? midiverb_effects : {},
    midifex: typeof midifex_effects !== 'undefined' ? midifex_effects : {},
    midiverb2: typeof midiverb2_effects !== 'undefined' ? midiverb2_effects : {}
  };

  // LFO patches for MIDIVerb 2 (programs 50-69)
  const LFO_PATCHES = {
    50: { type: 'triangle', max: 0x3fff, retrigger: true, top1: 0x00, top2: 0x00, rate1: 0x03, rate2: 0x03, nextInstrOpcode: 0xc0 },
    51: { type: 'triangle', max: 0x3fff, retrigger: false, top1: 0x00, top2: 0x00, rate1: 0x03, rate2: 0x05, nextInstrOpcode: 0x80 },
    52: { type: 'triangle', max: 0x3fff, retrigger: false, top1: 0x00, top2: 0x00, rate1: 0x05, rate2: 0x05, nextInstrOpcode: 0xc0 },
    53: { type: 'triangle', max: 0x7fff, retrigger: true, top1: 0x00, top2: 0x00, rate1: 0x06, rate2: 0x07, nextInstrOpcode: 0x80 },
    54: { type: 'triangle', max: 0x7fff, retrigger: false, top1: 0x00, top2: 0x00, rate1: 0x05, rate2: 0x05, nextInstrOpcode: 0xc0 },
    55: { type: 'triangle', max: 0x7fff, retrigger: false, top1: 0x00, top2: 0x00, rate1: 0x0c, rate2: 0x0c, nextInstrOpcode: 0x80 },
    56: { type: 'triangle', max: 0x7fff, retrigger: false, top1: 0x00, top2: 0x00, rate1: 0x11, rate2: 0x11, nextInstrOpcode: 0xc0 },
    57: { type: 'triangle', max: 0xffff, retrigger: true, top1: 0x00, top2: 0x00, rate1: 0x13, rate2: 0x17, nextInstrOpcode: 0x80 },
    58: { type: 'triangle', max: 0xffff, retrigger: false, top1: 0x00, top2: 0x00, rate1: 0x0d, rate2: 0x0e, nextInstrOpcode: 0xc0 },
    59: { type: 'triangle', max: 0xffff, retrigger: false, top1: 0x00, top2: 0x00, rate1: 0x17, rate2: 0x11, nextInstrOpcode: 0x80 },
    60: { type: 'sine', max: 0x7eff, retrigger: false, top1: 0x01, top2: 0x03, rate1: 0x27, rate2: 0x1b, nextInstrOpcode: 0x80 },
    61: { type: 'sine', max: 0x3eff, retrigger: false, top1: 0x02, top2: 0x03, rate1: 0x2e, rate2: 0x3d, nextInstrOpcode: 0x80 },
    62: { type: 'sine', max: 0x7eff, retrigger: false, top1: 0x02, top2: 0x01, rate1: 0x2d, rate2: 0x3a, nextInstrOpcode: 0x80 },
    63: { type: 'sine', max: 0x7eff, retrigger: false, top1: 0x03, top2: 0x02, rate1: 0x40, rate2: 0x45, nextInstrOpcode: 0x80 },
    64: { type: 'sine', max: 0x3eff, retrigger: false, top1: 0x02, top2: 0x03, rate1: 0x4f, rate2: 0x79, nextInstrOpcode: 0x80 },
    65: { type: 'sine', max: 0x3eff, retrigger: false, top1: 0x02, top2: 0x01, rate1: 0x94, rate2: 0x7a, nextInstrOpcode: 0x80 },
    66: { type: 'sine', max: 0x7eff, retrigger: false, top1: 0x02, top2: 0x01, rate1: 0x4f, rate2: 0x41, nextInstrOpcode: 0x80 },
    67: { type: 'sine', max: 0x3eff, retrigger: false, top1: 0x01, top2: 0x02, rate1: 0x70, rate2: 0x8e, nextInstrOpcode: 0x80 },
    68: { type: 'sine', max: 0x1eff, retrigger: false, top1: 0x01, top2: 0x01, rate1: 0xea * 4, rate2: 0xd9 * 4, nextInstrOpcode: 0x80 },
    69: { type: 'sine', max: 0x1eff, retrigger: false, top1: 0x01, top2: 0x01, rate1: 0xff * 4, rate2: 0xff * 4, nextInstrOpcode: 0x80 }
  };

  // LFO class
  class Lfo {
    constructor(type, rate, max) {
      this.type = type;
      this.rate = rate;
      this.max = max;
      this.reset();
    }

    reset() {
      if (this.type === 'triangle') {
        this.value = 0;
        this.dir = 1;
      } else { // sine
        this.x = 0;
        this.y = this.max & 0xff00;
      }
    }

    update() {
      if (this.type === 'triangle') {
        return this.updateTriangle();
      } else {
        return this.updateSine();
      }
    }

    updateTriangle() {
      if (this.dir) {
        this.value += this.rate;
        if (this.value > this.max) {
          this.value = this.max;
          this.dir = 0;
        }
      } else {
        this.value -= this.rate;
        if (this.value < 0) {
          this.value = 0;
          this.dir = 1;
        }
      }
      return this.value & 0xffff;
    }

    updateSine() {
      const clampPos = this.max;
      const clampNeg = -this.max;
      const rate = this.rate;

      // Y += X * rate >> 16
      this.y += (this.x * rate) >> 16;
      if (this.y > clampPos) this.y = clampPos;
      if (this.y < clampNeg) this.y = clampNeg;

      // X -= Y * rate >> 16
      this.x -= (this.y * rate) >> 16;
      if (this.x > clampPos) this.x = clampPos;
      if (this.x < clampNeg) this.x = clampNeg;

      // Convert signed to unsigned
      return (this.x ^ 0x8000) & 0xffff;
    }
  }

  // VST-style Biquad filter (transposed direct form II)
  class BiquadFilter {
    constructor() {
      this.b0 = 1; this.b1 = 0; this.b2 = 0;
      this.a1 = 0; this.a2 = 0;
      this.z1 = 0; this.z2 = 0;
    }
    reset() { this.z1 = this.z2 = 0; }
    process(x) {
      const y = this.b0 * x + this.z1;
      this.z1 = this.b1 * x - this.a1 * y + this.z2;
      this.z2 = this.b2 * x - this.a2 * y;
      return y;
    }
    setLowpass(sampleRate, cutoff, Q) {
      const w0 = 2.0 * Math.PI * cutoff / sampleRate;
      const cosw0 = Math.cos(w0);
      const sinw0 = Math.sin(w0);
      const alpha = sinw0 / (2.0 * Q);
      const a0 = 1.0 + alpha;
      this.b0 = ((1.0 - cosw0) / 2.0) / a0;
      this.b1 = (1.0 - cosw0) / a0;
      this.b2 = ((1.0 - cosw0) / 2.0) / a0;
      this.a1 = (-2.0 * cosw0) / a0;
      this.a2 = (1.0 - alpha) / a0;
    }
  }

  // 8th order Butterworth lowpass (4 cascaded biquads)
  class LowpassFilter8th {
    constructor() {
      this.sections = [new BiquadFilter(), new BiquadFilter(), new BiquadFilter(), new BiquadFilter()];
    }
    reset() { for (const s of this.sections) s.reset(); }
    setCutoff(sampleRate, cutoff) {
      const Qs = [0.5097956518, 0.6013448869, 0.8999197654, 2.5629154478];
      for (let i = 0; i < 4; i++) this.sections[i].setLowpass(sampleRate, cutoff, Qs[i]);
    }
    process(x) {
      for (const s of this.sections) x = s.process(x);
      return x;
    }
  }

  // Linear interpolation buffer for resampling (matches VST InputInterpBuffer/OutputInterpBuffer)
  class InterpBuffer {
    constructor() { this.data = [0, 0]; this.writePos = 0; }
    reset() { this.data = [0, 0]; this.writePos = 0; }
    push(x) { this.data[this.writePos] = x; this.writePos = (this.writePos + 1) % 2; }
    interpolate(frac) {
      const i0 = this.writePos;
      const i1 = (this.writePos + 1) % 2;
      return this.data[i0] + frac * (this.data[i1] - this.data[i0]);
    }
  }

  function Filterx2() {
    this.xv0 = 0; this.xv1 = 0; this.xv2 = 0; this.xv3 = 0; this.xv4 = 0;
    this.yv0 = 0; this.yv1 = 0; this.yv2 = 0; this.yv3 = 0; this.yv4 = 0;
    var GAIN = 1.481376007e+01;

    this.run = function(x) {
      this.xv0 = this.xv1; this.xv1 = this.xv2; this.xv2 = this.xv3; this.xv3 = this.xv4;
      this.xv4 = x / GAIN;
      this.yv0 = this.yv1; this.yv1 = this.yv2; this.yv2 = this.yv3; this.yv3 = this.yv4;
      this.yv4 = (this.xv0 + this.xv4) + 4 * (this.xv1 + this.xv3) + 6 * this.xv2
          + (-0.0206514245 * this.yv0) + (0.0842337122 * this.yv1)
          + (-0.5343006371 * this.yv2) + (0.3906414532 * this.yv3);
      return this.yv4;
    };
  }

  class Machine {
    constructor() {
      this.ProgramLength = 128;
      this.ProgramByteLength = 256;
      this.InterpolationPatchTableLength = 256;
      this.DramLength = 16 * 1024;
      this.address = 0;
      this.program = new Uint8Array(this.ProgramByteLength);
      this.interpolationPatchTable = new Uint8Array(this.InterpolationPatchTableLength);
      this.dram = new Int16Array(this.DramLength);
      this.acc = 0;
      this.last_output = 0;
      this.memoryShift = 2;
      this.romData = null;
      this.currentRomType = null;
      this.lfo1 = null;
      this.lfo2 = null;
      this.lfoPatch = null;
      this.hasActiveLfo = false;
    }

    async loadRom(romType) {
      if (this.currentRomType === romType && this.romData) {
        return; // ROM already loaded
      }
      try {
        const response = await fetch(romType.romFile);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        this.romData = new Uint8Array(await response.arrayBuffer());
        this.currentRomType = romType;
        this.memoryShift = romType.memoryShift;
      } catch (error) {
        console.error(`Failed to load ROM: ${error}`);
      }
    }

    loadProgram(romType, programNum) {
      if (!this.romData) return;

      const programIndex = programNum - romType.firstProgram;
      const offset = romType.bytecodeOffset + programIndex * this.ProgramByteLength;

      for (let i = 0; i < this.ProgramByteLength; i++) {
        this.program[i] = this.romData[offset + i];
      }

      // Load interpolation patch table for MIDIVerb 2
      if (romType.hasLfo && romType.interpolationPatchTableOffset) {
        for (let i = 0; i < this.InterpolationPatchTableLength; i++) {
          this.interpolationPatchTable[i] = this.romData[romType.interpolationPatchTableOffset + i];
        }
      }

      // Setup LFO if applicable
      this.hasActiveLfo = false;
      if (romType.hasLfo && LFO_PATCHES[programNum]) {
        const patch = LFO_PATCHES[programNum];
        this.lfo1 = new Lfo(patch.type, patch.rate1, patch.max);
        this.lfo2 = new Lfo(patch.type, patch.rate2, patch.max);
        this.lfoPatch = patch;
        this.hasActiveLfo = true;
      }
    }

    resetMachine() {
      this.dram.fill(0);
      this.acc = 0;
      this.address = 0;
      if (this.lfo1) this.lfo1.reset();
      if (this.lfo2) this.lfo2.reset();
    }

    fillDramWithRandomNumbers() {
      for (let i = 0; i < this.DramLength; i++) {
        this.dram[i] = Math.floor(Math.random() * 0xFFFF) - 0x8000;
      }
    }

    patchMachine(lfo1Value, lfo2Value) {
      if (!this.lfoPatch) return;

      const patch = this.lfoPatch;
      const program = this.program;
      const interpTable = this.interpolationPatchTable;

      // First LFO patch
      {
        const memoryShift = lfo1Value | ((patch.top1) << 16);
        const patchOffset = memoryShift & 0xf0;
        const sub = ((interpTable[patchOffset + 1] << 8) | interpTable[patchOffset]) - (memoryShift >> 8);
        const add = ((interpTable[patchOffset + 7] << 8) | interpTable[patchOffset + 6]) + (memoryShift >> 8);

        program[0x05] = sub & 0xff;
        program[0x06] = ((sub >> 8) & 0x3f) | 0x40;
        program[0x59] = interpTable[patchOffset + 2];
        program[0x5a] = interpTable[patchOffset + 3];
        program[0x5b] = interpTable[patchOffset + 4];
        program[0x5c] = interpTable[patchOffset + 5];
        program[0x5d] = add & 0xff;
        program[0x5e] = ((add >> 8) & 0x3f) | patch.nextInstrOpcode;
      }

      // Second LFO patch
      {
        const memoryShift = lfo2Value | ((patch.top2) << 16);
        const patchOffset = 8 + (memoryShift & 0xf0);
        const sub = ((interpTable[patchOffset + 1] << 8) | interpTable[patchOffset]) - (memoryShift >> 8);
        const add = ((interpTable[patchOffset + 7] << 8) | interpTable[patchOffset + 6]) + (memoryShift >> 8);

        program[0x5f] = sub & 0xff;
        program[0x60] = ((sub >> 8) & 0x3f) | 0x40;
        program[0xb3] = interpTable[patchOffset + 2];
        program[0xb4] = interpTable[patchOffset + 3];
        program[0xb5] = interpTable[patchOffset + 4];
        program[0xb6] = interpTable[patchOffset + 5];
        program[0xb7] = add & 0xff;
        program[0xb8] = ((add >> 8) & 0x3f) | patch.nextInstrOpcode;
      }
    }

    runMachineTick(input) {
      let acc = this.acc;
      let address = this.address;
      let output = { s: [0, 0] };
      const memShift = this.memoryShift;
      const program = this.program;

      for (let pc = 0; pc < 128; pc++) {
        const operation = program[(2 * pc - memShift - 1) & 0xff] >> 6;
        const offsetLo = program[(2 * pc - memShift + 0) & 0xff];
        const offsetHi = program[(2 * pc - memShift + 1) & 0xff] & 0x3f;
        const offset = (offsetHi << 8) | offsetLo;

        let newAcc = acc;
        let data, sgn;
        switch (operation) {
          case 0: // sumhlf
            data = this.dram[address];
            sgn = data < 0 ? 1 : 0;
            newAcc = newAcc + (data >> 1) + sgn;
            break;
          case 1: // ldhlf
            data = this.dram[address];
            sgn = data < 0 ? 1 : 0;
            newAcc = (data >> 1) + sgn;
            break;
          case 2: // strpos
            data = newAcc;
            sgn = data < 0 ? 1 : 0;
            this.dram[address] = data;
            newAcc = newAcc + (data >> 1) + sgn;
            break;
          case 3: // strneg
            data = ~newAcc;
            sgn = data < 0 ? 1 : 0;
            this.dram[address] = data;
            newAcc = (data >> 1) + sgn;
            break;
        }

        if (pc === 0x60) {
          output.s[0] = data;
        } else if (pc === 0x70) {
          output.s[1] = data;
        } else if (pc === 0) {
          this.dram[address] = input;
        } else {
          acc = newAcc;
        }

        address = (address + offset) % this.DramLength;
      }
      this.acc = acc;
      this.address = address;

      return output;
    }

    runEffect(leftIn, rightIn, feedbackAmount, useDecompiled = false, decompiledFunc = null, lfo1Value = 0, lfo2Value = 0) {
      const mono_sample = (leftIn + rightIn + this.last_output * feedbackAmount) >> 5;

      let left_out, right_out;

      if (useDecompiled && decompiledFunc) {
        // Run decompiled JavaScript function
        // Note: decompiled functions use ptr directly (not address) and share the same DRAM
        const [outLeft, outRight] = decompiledFunc(mono_sample, this.dram, this.address, lfo1Value, lfo2Value);
        left_out = this.clip((outLeft || 0) * 16);
        right_out = this.clip((outRight || 0) * 16);
        // Advance address by 1 (same as emulator does at end of tick)
        this.address = (this.address + 1) % this.DramLength;
      } else {
        // Run emulated ROM code
        const output = this.runMachineTick(mono_sample);
        left_out = this.clip(output.s[0] * 16);
        right_out = this.clip(output.s[1] * 16);
      }

      this.last_output = (left_out + right_out) / 2;

      return [left_out, right_out];
    }

    clip(input) {
      if (input > 32767) return 32767;
      if (input < -32768) return -32768;
      return input;
    }

    decodeInstruction(pc, address, memShift) {
      const program = this.program;
      const operation = program[(2 * pc - memShift - 1) & 0xff] >> 6;
      const offsetLo = program[(2 * pc - memShift + 0) & 0xff];
      const offsetHi = program[(2 * pc - memShift + 1) & 0xff] & 0x3f;
      const offset = (offsetHi << 8) | offsetLo;
      const curr = (offsetHi << 8) | offsetLo;

      let instruction;
      let data;
      let comment;

      switch (operation) {
        case 0b00:
          instruction = `sumhlf 0x${address.toString(16).padStart(4, '0')}`;
          data = `DRAM[0x${address.toString(16).padStart(4, '0')}]`;
          comment = `Acc = Acc + ${data}/2 + sgn`;
          break;
        case 0b01:
          instruction = `ldhlf  0x${address.toString(16).padStart(4, '0')}`;
          data = `DRAM[0x${address.toString(16).padStart(4, '0')}]`;
          comment = `Acc = ${data}/2 + sgn`;
          break;
        case 0b10:
          instruction = `strpos 0x${address.toString(16).padStart(4, '0')}`;
          data = `Acc`;
          comment = `DRAM[0x${address.toString(16).padStart(4, '0')}] = ${data}, Acc = Acc + ${data}/2 + sgn`;
          break;
        case 0b11:
          data = `~Acc`;
          instruction = `strneg 0x${address.toString(16).padStart(4, '0')}`;
          comment = `DRAM[0x${address.toString(16).padStart(4, '0')}] = ${data}, Acc = ${data}/2 + sgn`;
          break;
        default:
          instruction = "unknown";
          comment = "";
          break;
      }

      if (pc === 0x00) {
        comment = `DRAM[0x${address.toString(16).padStart(4, '0')}] = Input`;
      } else if (pc === 0x60) {
        comment = `Left = ${data}`;
      } else if (pc === 0x70) {
        comment = `Right = ${data}`;
      }

      return {
        instructionLine: `${pc.toString(16).padStart(2, '0')} ${operation} ${curr.toString(16).padStart(4, '0')}   ${instruction}    ${comment}`,
        newAddress: (address + offset) & 0x3fff
      };
    }

    disassemble() {
      let disassembledInstructions = [];
      let address = 0;

      for (let pc = 0; pc < 128; pc++) {
        let result = this.decodeInstruction(pc, address, this.memoryShift);
        disassembledInstructions.push(result.instructionLine);
        address = result.newAddress;
      }

      return {
        disassembledInstructions,
        endAddress: address
      };
    }
  }

  // Configuration - default device and effect
  const DEFAULT_DEVICE = 'midiverb2';
  const DEFAULT_PROGRAM = 1;
  const DEFAULT_ENGINE = 'emulated';

  // Global state
  let currentSoundSource = 'example.wav';
  let currentDevice = DEFAULT_DEVICE;
  let currentProgram = DEFAULT_PROGRAM;
  let currentEngine = DEFAULT_ENGINE;
  let currentDecompiledFunc = null;
  const machine = new Machine();
  let audioCtx = null;
  let source = null;
  let processor = null;
  let dryWetMix = 0.5;
  let isPaused = false;
  let feedbackAmount = 0.0;
  let downSamplingFilter0 = new Filterx2();
  let downSamplingFilter1 = new Filterx2();
  let upSamplingFilter0 = new Filterx2();
  let upSamplingFilter1 = new Filterx2();

  // VST-style resampling state
  const EFFECT_SAMPLE_RATE = 24000.0;
  const FILTER_CUTOFF = 10000.0;
  let vstAntiAliasFilter = new LowpassFilter8th();
  let vstInputBuffer = new InterpBuffer();
  let vstOutputBufferL = new InterpBuffer();
  let vstOutputBufferR = new InterpBuffer();
  let vstReconstructFilterL = new LowpassFilter8th();
  let vstReconstructFilterR = new LowpassFilter8th();
  let vstPhase = 0.0;
  let vstPhaseIncrement = 0.5;
  let vstLastWetL = 0.0;
  let vstLastWetR = 0.0;
  let vstLastLfo1 = 0;
  let vstLastLfo2 = 0;

  // Disassembly update throttling
  let lastDisassemblyUpdate = 0;
  const DISASSEMBLY_UPDATE_INTERVAL = 100; // 10 fps = 100ms interval
  let lfoTickCounter = 0;

  function populateEffectList(deviceKey) {
    const romType = ROM_TYPES[deviceKey];
    const effectSelect = document.getElementById('effectProgram');
    effectSelect.innerHTML = '';

    romType.effectNames.forEach((name, index) => {
      const option = document.createElement('option');
      option.value = romType.firstProgram + index;
      option.textContent = `${romType.firstProgram + index}: ${name}`;
      effectSelect.appendChild(option);
    });

    currentProgram = romType.firstProgram;
  }

  function getDecompiledFunc(device, program) {
    const effects = DECOMPILED_EFFECTS[device];
    if (effects && effects[program]) {
      return effects[program];
    }
    return null;
  }

  async function startAudio() {
    if (audioCtx !== null) {
      audioCtx.close();
    }

    const romType = ROM_TYPES[currentDevice];

    // For emulated mode, load ROM; for decompiled, we still need ROM for LFO patches
    if (currentEngine === 'emulated' || romType.hasLfo) {
      await machine.loadRom(romType);
      machine.loadProgram(romType, currentProgram);
    }

    // Get decompiled function if available
    currentDecompiledFunc = getDecompiledFunc(currentDevice, currentProgram);

    // Reset machine state (shared DRAM)
    machine.resetMachine();

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Initialize VST-style resampling filters at host sample rate
    const hostRate = audioCtx.sampleRate;
    vstPhaseIncrement = EFFECT_SAMPLE_RATE / hostRate;
    vstPhase = 0.0;
    vstAntiAliasFilter.setCutoff(hostRate, FILTER_CUTOFF);
    vstAntiAliasFilter.reset();
    vstReconstructFilterL.setCutoff(hostRate, FILTER_CUTOFF);
    vstReconstructFilterL.reset();
    vstReconstructFilterR.setCutoff(hostRate, FILTER_CUTOFF);
    vstReconstructFilterR.reset();
    vstInputBuffer.reset();
    vstOutputBufferL.reset();
    vstOutputBufferR.reset();
    vstLastWetL = 0; vstLastWetR = 0;
    vstLastLfo1 = 0; vstLastLfo2 = 0;

    const audioBuffer = await getAudioBuffer(audioCtx, currentSoundSource);

    source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.loop = true;

    let last_left = 0;
    let last_right = 0;
    lfoTickCounter = 0;

    processor = audioCtx.createScriptProcessor(4096, 2, 2);
    processor.onaudioprocess = (audioProcessingEvent) => {
      const inputBuffer = audioProcessingEvent.inputBuffer;
      const outputBuffer = audioProcessingEvent.outputBuffer;
      const useDecompiled = currentEngine === 'decompiled' && currentDecompiledFunc !== null;
      const useVstResampling = currentEngine === 'decompiled_vst' && currentDecompiledFunc !== null;

      for (let sample = 0; sample < inputBuffer.length; sample++) {
        let left = inputBuffer.numberOfChannels > 0 ? inputBuffer.getChannelData(0)[sample] : 0;
        let right = inputBuffer.numberOfChannels > 1 ? inputBuffer.getChannelData(1)[sample] : 0;
        if (isPaused) {
          left = 0;
          right = 0;
        }

        if (useVstResampling) {
          // VST-style resampling: 8th-order Butterworth + phase accumulator + linear interpolation
          // Sum to mono with feedback (matching VST PluginProcessor.cpp)
          let monoIn = (left + right) * 0.5 + (vstLastWetL + vstLastWetR) * 0.5 * feedbackAmount;
          let filtered = vstAntiAliasFilter.process(monoIn);
          vstInputBuffer.push(filtered);

          vstPhase += vstPhaseIncrement;
          while (vstPhase >= 1.0) {
            vstPhase -= 1.0;

            // Interpolate input at the exact fractional position
            let inputFrac = 1.0 - vstPhase / vstPhaseIncrement;
            let interpolatedInput = vstInputBuffer.interpolate(inputFrac);

            // Saturate and scale to 13-bit (Â±4095, matching VST's 0x0fff)
            if (interpolatedInput > 1.0) interpolatedInput = 1.0;
            if (interpolatedInput < -1.0) interpolatedInput = -1.0;
            let inputInt = (interpolatedInput * 0x0fff) | 0;

            // LFO handling (every 8 effect samples, matching VST LFO_UPDATE_INTERVAL)
            if (machine.hasActiveLfo) {
              if (lfoTickCounter % 8 === 0) {
                vstLastLfo1 = machine.lfo1.update();
                vstLastLfo2 = machine.lfo2.update();
                const now = performance.now();
                if (now - lastDisassemblyUpdate >= DISASSEMBLY_UPDATE_INTERVAL) {
                  lastDisassemblyUpdate = now;
                  requestAnimationFrame(() => displayDisassembly(currentProgram));
                }
              }
            }
            lfoTickCounter++;

            // Run decompiled effect directly (bypassing machine.runEffect)
            const [outL, outR] = currentDecompiledFunc(inputInt, machine.dram, machine.address, vstLastLfo1, vstLastLfo2);
            machine.address = (machine.address + 1) % machine.DramLength;

            // Scale output back to float (13-bit to [-1, 1])
            vstOutputBufferL.push((outL || 0) / 0x0fff);
            vstOutputBufferR.push((outR || 0) / 0x0fff);
          }

          // Interpolate output at host sample rate
          let wetL = vstOutputBufferL.interpolate(vstPhase);
          let wetR = vstOutputBufferR.interpolate(vstPhase);

          // Reconstruction filter
          wetL = vstReconstructFilterL.process(wetL);
          wetR = vstReconstructFilterR.process(wetR);

          vstLastWetL = wetL;
          vstLastWetR = wetR;

          outputBuffer.getChannelData(0)[sample] = (1 - dryWetMix) * left + dryWetMix * wetL;
          outputBuffer.getChannelData(1)[sample] = (1 - dryWetMix) * right + dryWetMix * wetR;
        } else {
          // Original resampling: 4th-order filter + 2x decimation
          const left_ds = downSamplingFilter0.run(left);
          const right_ds = downSamplingFilter1.run(right);
          if (sample % 2 == 0) {
            // Get LFO values for both modes
            let lfo1Value = 0, lfo2Value = 0;

            // Run LFO every ~8 samples (matching C code timing)
            if (machine.hasActiveLfo && lfoTickCounter % 8 === 0) {
              lfo1Value = machine.lfo1.update();
              lfo2Value = machine.lfo2.update();
              // For emulated mode, patch the machine; for decompiled, pass values to function
              if (!useDecompiled) {
                machine.patchMachine(lfo1Value, lfo2Value);
              }

              // Throttled disassembly update
              const now = performance.now();
              if (now - lastDisassemblyUpdate >= DISASSEMBLY_UPDATE_INTERVAL) {
                lastDisassemblyUpdate = now;
                requestAnimationFrame(() => displayDisassembly(currentProgram));
              }
            }
            // Get current LFO values for decompiled mode
            if (useDecompiled && machine.hasActiveLfo) {
              lfo1Value = machine.lfo1 ? machine.lfo1.value || 0 : 0;
              lfo2Value = machine.lfo2 ? machine.lfo2.value || 0 : 0;
            }
            lfoTickCounter++;

            const [left_out, right_out] = machine.runEffect(
              (left_ds * 32767.0)|0,
              (right_ds * 32767.0)|0,
              feedbackAmount,
              useDecompiled,
              currentDecompiledFunc,
              lfo1Value,
              lfo2Value
            );
            last_left = left_out / 32767.0;
            last_right = right_out / 32767.0;
          }
          let left_us = upSamplingFilter0.run(last_left);
          let right_us = upSamplingFilter1.run(last_right);

          outputBuffer.getChannelData(0)[sample] = (1 - dryWetMix) * left + dryWetMix * left_us;
          outputBuffer.getChannelData(1)[sample] = (1 - dryWetMix) * right + dryWetMix * right_us;
        }
      }
    };

    source.connect(processor);
    processor.connect(audioCtx.destination);
    source.start(0);

    displayDisassembly(currentProgram);
  }

  function stopAudio() {
    if (source !== null) {
      source.stop();
    }
    if (processor !== null) {
      processor.disconnect();
    }
    if (audioCtx !== null) {
      audioCtx.close();
      audioCtx = null;
    }
  }

  function pauseAudio() {
    isPaused = !isPaused;
    if (isPaused) {
      document.getElementById('pauseButton').innerText = 'Unmute effect input';
    } else {
      document.getElementById('pauseButton').innerText = 'Mute effect input';
    }
  }

  function displayDisassembly(programNumber) {
    const romType = ROM_TYPES[currentDevice];
    const effectName = romType.effectNames[programNumber - romType.firstProgram] || '';
    const lfoInfo = machine.hasActiveLfo ? ' [LFO Active]' : '';
    const engineInfo = currentEngine === 'decompiled'
      ? (currentDecompiledFunc ? ' [Decompiled JS]' : ' [Decompiled - Not Available, Using Emulated]')
      : currentEngine === 'decompiled_vst'
      ? (currentDecompiledFunc ? ' [Decompiled JS + VST Resampling]' : ' [VST Resampling - Not Available, Using Emulated]')
      : ' [Emulated ROM]';
    const disassembled = machine.disassemble().disassembledInstructions;
    const disassemblyContainer = document.getElementById('disassemblyContainer');
    disassemblyContainer.innerHTML = `<h3>${romType.name} Program #${programNumber}: ${effectName}${lfoInfo}${engineInfo}</h3><pre>${disassembled.join('\n')}</pre>`;
  }

  // Event listeners
  document.getElementById('startButton').addEventListener('click', startAudio);
  document.getElementById('stopButton').addEventListener('click', stopAudio);
  document.getElementById('pauseButton').addEventListener('click', pauseAudio);

  document.getElementById('engineSelect').addEventListener('change', (event) => {
    currentEngine = event.target.value;
    currentDecompiledFunc = getDecompiledFunc(currentDevice, currentProgram);
    displayDisassembly(currentProgram);
  });

  document.getElementById('deviceSelect').addEventListener('change', async (event) => {
    currentDevice = event.target.value;
    populateEffectList(currentDevice);

    const romType = ROM_TYPES[currentDevice];
    if (currentEngine === 'emulated' || romType.hasLfo) {
      await machine.loadRom(romType);
      machine.loadProgram(romType, currentProgram);
    }
    currentDecompiledFunc = getDecompiledFunc(currentDevice, currentProgram);
    machine.resetMachine();
    displayDisassembly(currentProgram);
  });

  document.getElementById('effectProgram').addEventListener('change', async (event) => {
    currentProgram = parseInt(event.target.value);
    const romType = ROM_TYPES[currentDevice];
    if (currentEngine === 'emulated' || romType.hasLfo) {
      await machine.loadRom(romType);
      machine.loadProgram(romType, currentProgram);
    }
    currentDecompiledFunc = getDecompiledFunc(currentDevice, currentProgram);
    machine.resetMachine();
    displayDisassembly(currentProgram);
  });

  document.getElementById('dryWetMix').addEventListener('input', (event) => {
    dryWetMix = event.target.value / 100;
  });

  document.getElementById('feedbackAmount').addEventListener('input', (event) => {
    feedbackAmount = event.target.value / 100;
  });

  document.getElementById('soundSelect').addEventListener('change', (event) => {
    if (event.target.value === 'custom') {
      document.getElementById('fileInput').click();
    } else {
      currentSoundSource = event.target.value;
      stopAudio();
      startAudio();
    }
  });

  document.getElementById('fileInput').addEventListener('change', (event) => {
    if (event.target.files.length > 0) {
      const file = event.target.files[0];
      currentSoundSource = URL.createObjectURL(file);
      // Update dropdown to show custom file name
      const customOption = document.querySelector('#soundSelect option[value="custom"]');
      customOption.textContent = `Custom: ${file.name}`;
      stopAudio();
      startAudio();
    } else {
      // User cancelled, revert to previous selection
      document.getElementById('soundSelect').value = currentSoundSource;
    }
  });

  document.getElementById('fillDramButton').addEventListener('click', () => {
    machine.fillDramWithRandomNumbers();
  });

  // Initialize on load
  populateEffectList(DEFAULT_DEVICE);
  // Set default program in the effect dropdown
  document.getElementById('effectProgram').value = DEFAULT_PROGRAM;
  currentProgram = DEFAULT_PROGRAM;
  </script>
</body>
</html>
